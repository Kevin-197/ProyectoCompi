package compi;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.IOException;

parser code
{:
    private ArrayList<Symbol> s = new ArrayList<Symbol>();
    
    public void syntax_error(Symbol s){
        this.s.add(s);
    }

    public ArrayList<Symbol> getS(){
        return this.s;
    }
    
    protected final static int _error_sync_size = 3;
    protected int error_sync_size( ) {
        return _error_sync_size;
    }

    public TablaSimbolos tabla = TablaSimbolos.getInstance();
    public PilaSemantica pila = PilaSemantica.getInstance();
    public int contadorWhile=0;
    public String rutaEnsamblador = "D:/RepoVR/ProyectoCompi/Compi/src/compi/Esamblador.asm";
    public int contadorIf = 0;
    
    public void GuardarRS_Tipo(String Tipo){
        RS_Tipo tipo = new RS_Tipo(Tipo);
        this.pila.Push(tipo);
    }

    public void GuardarRS_Var(String Id, int Line, int Column){
        RS_Var var = new RS_Var(Id,Line,Column);
        this.pila.Push(var);
    }
    
    public void GuardarRS_Param(String Id, int Line, int Column){
        RS_Param param = new RS_Param(Id,Line,Column);
        this.pila.Push(param);
    }

    public void BuscarSimbolo(String Id, int Line, int Column, String Ambito){
        RegistroTS a = this.tabla.BuscarSimboloDeclarado(Id, Ambito);
        if(a==null){
            System.out.println("\u001B[31mError semantico. Linea: " + Line + " Columna: " + Column +  " No ha sido declarado el identificador \""+Id+"\"\u001B[31m");
        }
    }
    
    public void ValidarLlamadaFunc(String Id, int Line, int Column){
        this.pila.ValidarLlamadaFunc(Id, Line, Column);
    }

    public Boolean init = true; 
    public void GuardarDeclaracionTS(String Ambito){
        if(init == true){
            System.out.println("section .data");
            init = false;
        }
        this.pila.GuardarVariable(Ambito);

    }
    
    public void StartWhile(){
        String label1 =  "while_label" + Integer.toString(this.contadorWhile);
        String label2 =  "exit_label" + Integer.toString(this.contadorWhile); 
        RS_While rs_while = new RS_While(label1,label2);
        System.out.println(rs_while.label1 + ":");
        this.pila.Push(rs_while);
        this.contadorWhile++;
    }

    public void TestWhile(){
        System.out.println("POP RS_DO");
        System.out.println("CODIGO EVALUACION");
        RS_While rs_while = pila.BuscarRS_While();
        System.out.println("jmp " + rs_while.label2);
    }

    public void EndWhile(){
        RS_While rs_while = pila.BuscarRS_While();
        System.out.println("jmp " + rs_while.label1);
        System.out.println(rs_while.label2 + ":");
        this.pila.Pop();
    }

    public void StartIf(String Else_label, String Exit_label){
        System.out.println("Start If");
        RS_If if_else = new RS_If(Else_label,Exit_label,contadorIf);
        this.pila.Push(if_else);
        contadorIf++;
    }

    public void TestIf(){
        try{

            FileWriter escritorEnsamblador = new FileWriter(rutaEnsamblador,true);
            System.out.println();
            System.out.println("Test If");
            System.out.println("Pop(RS_DO)");
            System.out.println("Evaluar la expresion");
            RS_If if_else = this.pila.BuscarRSIf();
            escritorEnsamblador.write("jg " + if_else.Else_label + "\n");
            escritorEnsamblador.close();
        }
        catch (IOException e){
            e.printStackTrace();
        }
    }

    public void StartElse(){
        try{
            FileWriter escritorEnsamblador = new FileWriter(rutaEnsamblador,true);
            System.out.println("Start Else");
            RS_If if_else = this.pila.BuscarRSIf();
            escritorEnsamblador.write("jmp " + if_else.Exit_label + "\n");
            escritorEnsamblador.write(if_else.Else_label + ":" + "\n");
            escritorEnsamblador.close();
        }
        catch (IOException e){
            e.printStackTrace();
        }
    }

    public void EndIf(){
        try{
            FileWriter escritorEnsamblador = new FileWriter(rutaEnsamblador,true);
            System.out.println("End If");
            RS_If if_else = this.pila.BuscarRSIf();
            escritorEnsamblador.write(if_else.Exit_label + ":" + "\n");
            escritorEnsamblador.close();
            this.pila.Pop();
        }
        catch (IOException e){
            e.printStackTrace();
        }
    }

:};

terminal Define, Write, Read, Break, Case, Char, Const, Continue, Default, Do, Else, For,
    If, Integer, Long, Return, Short, Switch, Void, While, OperadorSuma, 
    OperadorResta, OperadorMulti, OperadorDiv, OperadorMod, 
    OperadorAsignacionSuma, OperadorAsignacionResta, OperadorAsignacionMul,
    OperadorAsignacionDiv, OperadorAsignacion, OperadorIncremento, OperadorDecremento, 
    OperadorComparacion, OperadorMenor, OperadorMayor, OperadorMayorIgual, OperadorMenorIgual,
    OperadorDiferencia, OperadorNegacion, OperadorAnd, OperadorOr, 
    ParentesisA, ParentesisC, LlaveA, LlaveC, Coma, PuntoComa, DosPuntos, Int, Identificador, LiteralChar, ERROR;

non terminal FUNCION, SENTENCIA, PARAMETROS, OPERADOR_ARITMETICO2, OPERADOR_ARITMETICO1, 
    DATO_PREFIX, OPERADOR_BOOL, OPERADOR_OR_AND, OPERADOR_ASIG, TIPO_DATO, DATO,
    DECLARACION_LIST, DECLARACION, OPERACION, OPERACION1, OPERACION2, FACTOR, EXPRESION, IF, IF_ELSE,
    INSTRUCCIONES_CONTROL, WHILE, DO_WHILE, SENTENCIA_BOOLEANA, SENTENCIA_FOR, LISTA_EXPRESIONES, FOR,
    READ, WRITE, LISTA_IDENTIFICADORES, INICIO, INICIO_B, SWITCH, ETIQUETA_SWITCH, OPERACION_SWITCH1,
    OPERACION_SWITCH2, CONSTANT_FACTOR, NOMBRE_FUNCION, TIPO_DATO_FUNCION;

start with INICIO;

INICIO ::= 
    Define Identificador EXPRESION INICIO |
    Define Identificador EXPRESION PuntoComa INICIO |
    DECLARACION {: parser.GuardarDeclaracionTS("Global"); :} INICIO |
    FUNCION |
    error LlaveC INICIO_B |
    error PuntoComa INICIO
;
INICIO_B ::= 
    Define Identificador EXPRESION INICIO_B  |
    Define Identificador EXPRESION PuntoComa INICIO_B  |
    DECLARACION {: parser.GuardarDeclaracionTS("Global"); :} INICIO_B |
    Define Identificador EXPRESION |
    Define Identificador EXPRESION PuntoComa |
    DECLARACION {: parser.GuardarDeclaracionTS("Global"); :} |
    FUNCION |
    error LlaveC INICIO_B |
    error PuntoComa INICIO_B
;
FUNCION ::= 
    TIPO_DATO NOMBRE_FUNCION ParentesisA PARAMETROS ParentesisC LlaveA SENTENCIA LlaveC {: parser.tabla.TerminaFuncion(); :} |
    TIPO_DATO_FUNCION NOMBRE_FUNCION ParentesisA PARAMETROS ParentesisC LlaveA SENTENCIA LlaveC {: parser.tabla.TerminaFuncion(); :} |
    TIPO_DATO NOMBRE_FUNCION ParentesisA PARAMETROS ParentesisC LlaveA SENTENCIA LlaveC {: parser.tabla.TerminaFuncion(); :} INICIO_B |
    TIPO_DATO_FUNCION NOMBRE_FUNCION ParentesisA PARAMETROS ParentesisC LlaveA SENTENCIA LlaveC {: parser.tabla.TerminaFuncion(); :} INICIO_B 
;
TIPO_DATO_FUNCION ::= 
    Void {: parser.GuardarRS_Tipo("void"); :}
;
NOMBRE_FUNCION ::=
    Identificador:v1 {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1);
    parser.GuardarDeclaracionTS("Funcion"); :}
; 
SENTENCIA ::= 
    SENTENCIA DECLARACION {: parser.GuardarDeclaracionTS("Local"); :} |
    DECLARACION {: parser.GuardarDeclaracionTS("Local"); :} |
    SENTENCIA EXPRESION PuntoComa |
    EXPRESION PuntoComa |
    SENTENCIA INSTRUCCIONES_CONTROL |
    INSTRUCCIONES_CONTROL |
    SENTENCIA READ |
    READ |
    SENTENCIA WRITE |
    WRITE |
    SENTENCIA IF | 
    IF |
    SENTENCIA IF_ELSE |
    IF_ELSE |
    SENTENCIA WHILE |
    WHILE |
    SENTENCIA DO_WHILE |
    DO_WHILE |
    SENTENCIA FOR |
    FOR |
    SENTENCIA SWITCH |
    SWITCH |
    SENTENCIA Define Identificador EXPRESION PuntoComa |
    Define Identificador EXPRESION PuntoComa |
    error PuntoComa |
    error LlaveC | 
    error ParentesisC
;
PARAMETROS ::= 
    TIPO_DATO Identificador:v1 {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1);
    parser.GuardarDeclaracionTS("Parametro"); :}  |
    PARAMETROS Coma TIPO_DATO Identificador:v1 {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1);
    parser.GuardarDeclaracionTS("Parametro"); :} |
;
INSTRUCCIONES_CONTROL ::= 
    Return EXPRESION PuntoComa |
    Return PuntoComa |
    Break PuntoComa |
    Continue PuntoComa
;
OPERADOR_ARITMETICO2 ::= 
    OperadorMulti |
    OperadorDiv | 
    OperadorMod
;
OPERADOR_ARITMETICO1 ::= 
    OperadorSuma | 
    OperadorResta 
;
DATO_PREFIX ::= 
    OperadorSuma | 
    OperadorResta |
    OperadorNegacion  
;
OPERADOR_BOOL ::= 
    OperadorComparacion {: RESULT="=="; :} |
    OperadorMenor {: RESULT="char"; :} | 
    OperadorMayor {: RESULT="char"; :} | 
    OperadorMayorIgual {: RESULT="char"; :} | 
    OperadorMenorIgual {: RESULT="char"; :} |
    OperadorDiferencia {: RESULT="char"; :} 
;
OPERADOR_OR_AND ::= 
    OperadorOr |
    OperadorAnd 
;
OPERADOR_ASIG ::= 
    OperadorAsignacion |
    OperadorAsignacionSuma | 
    OperadorAsignacionResta | 
    OperadorAsignacionMul |
    OperadorAsignacionDiv 
;
TIPO_DATO ::= 
    Char {: parser.GuardarRS_Tipo("char"); :} |
    Integer {: parser.GuardarRS_Tipo("int"); :} | 
    Long {: parser.GuardarRS_Tipo("long"); :} | 
    Short {: parser.GuardarRS_Tipo("short"); :} |
    Short Integer {: parser.GuardarRS_Tipo("short int"); :} | 
    Long Integer {: parser.GuardarRS_Tipo("long int"); :}
;
DATO ::= 
    LiteralChar |
    Int |
    Identificador:v1 {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :}
;
DECLARACION_LIST ::= 
    Identificador:v1 {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1); :} |
    DECLARACION_LIST Coma Identificador:v1 {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1); :} |
    Identificador:v1 OperadorAsignacion OPERACION {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1); :} |
    DECLARACION_LIST Coma Identificador:v1 OperadorAsignacion OPERACION {: parser.GuardarRS_Var(v1.toString(),v1right +1,v1left +1); :}
;
DECLARACION ::= 
    TIPO_DATO DECLARACION_LIST PuntoComa |
    TIPO_DATO Const DECLARACION_LIST PuntoComa |  
    Const TIPO_DATO DECLARACION_LIST PuntoComa
;
OPERACION ::= 
    OPERACION OPERADOR_BOOL OPERACION1 | 
    OPERACION1
;
OPERACION1 ::= 
    OPERACION1 OPERADOR_ARITMETICO1 OPERACION2 | 
    OPERACION2
;
OPERACION2 ::= 
    OPERACION2 OPERADOR_ARITMETICO2 FACTOR | 
    FACTOR
;
FACTOR ::= 
    ParentesisA EXPRESION ParentesisC | 
    DATO_PREFIX ParentesisA EXPRESION ParentesisC | 
    DATO_PREFIX DATO |
    DATO |
    OperadorDecremento Identificador:v1 {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :} |
    OperadorIncremento Identificador:v1 {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :} |
    Identificador:v1 OperadorDecremento {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :} |
    Identificador:v1 OperadorIncremento {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :} |
    Identificador:v1 ParentesisA LISTA_IDENTIFICADORES ParentesisC {: parser.ValidarLlamadaFunc(v1.toString(),v1right +1,v1left +1); :} |
    Identificador:v1 ParentesisA ParentesisC {: parser.ValidarLlamadaFunc(v1.toString(),v1right +1,v1left +1); :}
;
EXPRESION ::= 
    Identificador:v1 OPERADOR_ASIG OPERACION {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :} |
    OPERACION 
;
READ ::= Read ParentesisA ParentesisC PuntoComa |
    Read ParentesisA LISTA_IDENTIFICADORES ParentesisC PuntoComa
;
WRITE ::= Write ParentesisA LISTA_EXPRESIONES ParentesisC PuntoComa
;
IF ::= If {: parser.StartIf("else_label","exit_label"); :} ParentesisA SENTENCIA_BOOLEANA ParentesisC {: parser.TestIf(); :} LlaveA SENTENCIA LlaveC
;
SENTENCIA_BOOLEANA ::= 
    OPERACION |
    Identificador:v1 OPERADOR_ASIG OPERACION {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); :}|
    SENTENCIA_BOOLEANA OPERADOR_OR_AND OPERACION 
;
IF_ELSE ::= IF Else {: parser.StartElse(); :} LlaveA SENTENCIA LlaveC {: parser.EndIf(); :}
;
WHILE ::= While {: parser.StartWhile(); :} ParentesisA SENTENCIA_BOOLEANA ParentesisC {: parser.TestWhile(); :} LlaveA SENTENCIA LlaveC {: parser.EndWhile(); :}
;
DO_WHILE ::= Do LlaveA SENTENCIA LlaveC While ParentesisA SENTENCIA_BOOLEANA ParentesisC PuntoComa
;
FOR ::= For ParentesisA SENTENCIA_FOR ParentesisC LlaveA SENTENCIA LlaveC
;
SENTENCIA_FOR ::=
    TIPO_DATO DECLARACION_LIST PuntoComa SENTENCIA_BOOLEANA PuntoComa LISTA_EXPRESIONES |
    DECLARACION_LIST PuntoComa SENTENCIA_BOOLEANA PuntoComa LISTA_EXPRESIONES
;
SWITCH ::= Switch ParentesisA SENTENCIA_BOOLEANA ParentesisC LlaveA ETIQUETA_SWITCH LlaveC
;
ETIQUETA_SWITCH ::=
    ETIQUETA_SWITCH Case OPERACION_SWITCH1 DosPuntos SENTENCIA |
    Case OPERACION_SWITCH1 DosPuntos SENTENCIA |
    ETIQUETA_SWITCH Default DosPuntos SENTENCIA |
    Default DosPuntos SENTENCIA |
    error DosPuntos |
    error PuntoComa
;
OPERACION_SWITCH1 ::= 
    OPERACION_SWITCH1 OPERADOR_ARITMETICO1 OPERACION_SWITCH2 | 
    OPERACION_SWITCH2
;
OPERACION_SWITCH2 ::= 
    OPERACION_SWITCH2 OPERADOR_ARITMETICO2 CONSTANT_FACTOR | 
    CONSTANT_FACTOR
;
CONSTANT_FACTOR ::= 
    ParentesisA OPERACION_SWITCH1 ParentesisC | 
    DATO_PREFIX ParentesisA OPERACION_SWITCH1 ParentesisC | 
    DATO_PREFIX Int |
    Int |
    DATO_PREFIX LiteralChar |
    LiteralChar
;
LISTA_EXPRESIONES ::= 
    EXPRESION |
    LISTA_EXPRESIONES Coma EXPRESION  
;
LISTA_IDENTIFICADORES ::= 
    Identificador:v1 {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); 
    parser.GuardarRS_Param(v1.toString(),v1right +1,v1left +1); :} |
    LISTA_IDENTIFICADORES Coma Identificador:v1 {: parser.BuscarSimbolo(v1.toString(),v1right +1,v1left +1, "Local"); 
    parser.GuardarRS_Param(v1.toString(),v1right +1,v1left +1); :}
;